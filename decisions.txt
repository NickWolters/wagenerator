Any NT first/follow set must be calculated at runtime. We can terminate once we exhaust all options and the optionally check a T which has a pre-defined first set
Use dynamic programming to make it "fast"

For `test` we pass a list of literals in this block. We check the first one, if it matches, done. If not, if it contains epsilon we check the next one.
This avoids having to create a FOLLOW set. Since we're doing runtime calculation already anyway it's not a big slowdown.

Fuck lexing, all my homies hate lexing. We scannerless now.
Could define and recognize regexes at runtime. Can compile all known regex machines beforehand to speed things up.

The one attribute paper destroys sharing by creating new nodes with a context every time the context is different
Instead of doing this, we can create a vector of contexts where the position in the vector maps to the n-th parent/child that this context should pass to
This does not solve the left-recursing problem (which I think is impossible with infinite context space), but brings back sharing.
TLDR: Instead of S where the left E inherits/synthesizes from/to A, we can do S where A is the 1st parent and B is the 2nd parent
                / \                                                          / \
               A   B                                                        A   B
              /     \                                                        \ /
             E       E                                                        E
           <p=1>   <p=2>                                                [<p=1>, <p=2>]
On the SPPF, this is essentially the same as putting the date on the corresponding edge. So we could probably just do that as well

& => by reference => synthesized (kind of like Rust &mut)
* => dereferenced/by value => inherited 
$ => local

# What to do with weights
1. Just annotate and return full tree as normal
2. Attempt highest value, given accepting first set
3. Attempt highest value, regardless of first set (thus allowing it to fail)
4. 2/3 but with lowest value


A(&a) -> B(&a, $b)?

A(&a) -> B(&a, $b)?
A(&a) -> A_0_0(&a, $b)
A_0_0(&a, &b) -> B(&a, &b) | 

A(&a) -> B(&a, $b)&
A(&a) -> A_0_0(&a, $b)
A_0_0(&a, &b) -> B(&a. &b) A_0_0(&a. &b) | 

A(&a) -> B(&a, $b)+
A(&a) -> A_0_0(&a, $b)
A_0_0(&a, &b) -> B(&a, &b) A_0_0_p(&a, &b)
A_0_0_p(&a, &b) -> B(&a, &b) A_0_0_p(&a, &b) | 

A(&a) -> (B($b)& C($c)?)?

A(&a) -> A_0_0__0?
A_0_0__0 -> B($b)& C($c)?

A(&a) -> A_0_0__0_0_0($b, $c)
A_0_0__0_0_0(&b, &c) -> A_0_0__0(&b, &c) | 
A_0_0__0(&b, &c) -> B(&b)& C(&c)?

Any attrs we can not find inside of () can be assumed to be from outside and must be passed in.
Any attrs we CAN find are constructed inside of the ().
Attributes inside () or EBNF MUST by synthesized. 

Could be good idea to disallow multiple types of attributes for the same "name". If you want that, just use a different name or something.
Reason is that this conflicts with rewrites of (), which require all passed arguments to be synthesized.

We know if GSS cycles exist. A GSS cycle implies left-recursion and thus a SPPF cycle. As such, if now GSS cycle exist, we should also not allow SPPF cycles.
In get_node_p, we pass whether this is a GSS cycle and if it isn't, we disallow packed nodes that would cause an SPPF cycle.
The reason we need to do this is because of attributes. Attributes can cause a GSS cycle to not occur, but an SPPF cycle to occur. We need to catch this case.