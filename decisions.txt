Any NT first/follow set must be calculated at runtime. We can terminate once we exhaust all options and the optionally check a T which has a pre-defined first set
Use dynamic programming to make it "fast"

For `test` we pass a list of literals in this block. We check the first one, if it matches, done. If not, if it contains epsilon we check the next one.
This avoids having to create a FOLLOW set. Since we're doing runtime calculation already anyway it's not a big slowdown.

Fuck lexing, all my homies hate lexing. We scannerless now.
Could define and recognize regexes at runtime. Can compile all known regex machines beforehand to speed things up.

The one attribute paper destroys sharing by creating new nodes with a context every time the context is different
Instead of doing this, we can create a vector of contexts where the position in the vector maps to the n-th parent/child that this context should pass to
This does not solve the left-recursing problem (which I think is impossible with infinite context space), but brings back sharing.
TLDR: Instead of S where the left E inherits/synthesizes from/to A, we can do S where A is the 1st parent and B is the 2nd parent
                / \                                                          / \
               A   B                                                        A   B
              /     \                                                        \ /
             E       E                                                        E
           <p=1>   <p=2>                                                [<p=1>, <p=2>]
On the SPPF, this is essentially the same as putting the date on the corresponding edge. So we could probably just do that as well

& => by reference => synthesizd
* => dereferenced/by value => inherited
$ => local

X -> [$x] <$y> A
   | [$z] <$y> B