# Generated by Grammarinator 23.7.post95+g3840454

from math import inf
from grammarinator.runtime import *

class wagGenerator(Generator):


    def wag(self, parent=None): 
        with UnparserRuleContext(self, 'wag', parent) as rule:
            current = rule.current
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[1], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.metadata(parent=current)
            current = rule.current
            with QuantifierContext(rule, 1, 0, inf, wagGenerator._quant_sizes[2], 0) as quant1:
                while quant1():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.rule(parent=current)
            current = rule.current
            return current

    def metadata(self, parent=None):
        with UnparserRuleContext(self, 'metadata', parent) as rule:
            current = rule.current
            with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[3], 1) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.meta(parent=current)
            current = rule.current
            self.META_END(parent=current)
            return current

    def meta(self, parent=None):
        with UnparserRuleContext(self, 'meta', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[3], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                [self.include, self.config][alt0()](parent=current)
            current = rule.current
            return current

    def include(self, parent=None):
        with UnparserRuleContext(self, 'include', parent) as rule:
            current = rule.current
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[4], 2) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.IDENTIFIER(parent=current)
            current = rule.current
            self._reserve(1, self.INCLUDEDECL, parent=current)
            self.IDENTIFIER(parent=current)
            with QuantifierContext(rule, 1, 0, 1, wagGenerator._quant_sizes[5], 0) as quant1:
                while quant1():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.include(parent=current)
            current = rule.current
            return current

    def config(self, parent=None):
        with UnparserRuleContext(self, 'config', parent) as rule:
            current = rule.current
            self._reserve(3, self.IDENTIFIER, parent=current)
            self._reserve(2, self.DECLARATION, parent=current)
            self._reserve(1, self.IDENTIFIER, parent=current)
            self.STATEMENT_END(parent=current)
            return current

    def rule(self, parent=None):
        with UnparserRuleContext(self, 'rule', parent) as rule:
            current = rule.current
            self._reserve(2, self.IDENTIFIER, parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[6], 2) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.nTArgs(parent=current)
            current = rule.current
            self._reserve(1, self.PROPESITION_SIGN, parent=current)
            self._reserve(1, self.rhs, parent=current)
            self.STATEMENT_END(parent=current)
            return current

    def rhs(self, parent=None):
        with UnparserRuleContext(self, 'rhs', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[4], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                choice0 = alt0()
                if choice0 == 0:
                    with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[3], 1) as quant0:
                        while quant0():
                            with QuantifiedContext(rule):
                                current = rule.current
                                self.weight(parent=current)
                    current = rule.current
                    with QuantifierContext(rule, 1, 0, inf, wagGenerator._quant_sizes[7], 1) as quant1:
                        while quant1():
                            with QuantifiedContext(rule):
                                current = rule.current
                                self.chunk(parent=current)
                    current = rule.current
                    self.EBNF_OPTION(parent=current)
                    self.rhs(parent=current)
                elif choice0 == 1:
                    with QuantifierContext(rule, 2, 0, 1, wagGenerator._quant_sizes[3], 0) as quant2:
                        while quant2():
                            with QuantifiedContext(rule):
                                current = rule.current
                                self.weight(parent=current)
                    current = rule.current
                    with QuantifierContext(rule, 3, 0, inf, wagGenerator._quant_sizes[7], 0) as quant3:
                        while quant3():
                            with QuantifiedContext(rule):
                                current = rule.current
                                self.chunk(parent=current)
                    current = rule.current
            current = rule.current
            return current

    def weight(self, parent=None):
        with UnparserRuleContext(self, 'weight', parent) as rule:
            current = rule.current
            self._reserve(1, self.BRACKET_L, parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[1], 1) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.attrIdentifier(parent=current)
            current = rule.current
            self._reserve(1, self.expression, parent=current)
            self.BRACKET_R(parent=current)
            return current

    def chunk(self, parent=None):
        with UnparserRuleContext(self, 'chunk', parent) as rule:
            current = rule.current
            self.chunkP(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[4], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.EBNFTYPE(parent=current)
            current = rule.current
            return current

    def chunkP(self, parent=None):
        with UnparserRuleContext(self, 'chunkP', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[5], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                choice0 = alt0()
                if choice0 == 0:
                    self.symbol(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.LPAREN, parent=current)
                    with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[7], 1) as quant0:
                        while quant0():
                            with QuantifiedContext(rule):
                                current = rule.current
                                self.chunk(parent=current)
                    current = rule.current
                    self.RPAREN(parent=current)
            current = rule.current
            return current

    def symbol(self, parent=None):
        with UnparserRuleContext(self, 'symbol', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[6], 0, wagGenerator._alt_conds[1]) as alt0:
                current = rule.current
                [self.nonTerminal, self.terminal, self.assignment][alt0()](parent=current)
            current = rule.current
            return current

    def terminal(self, parent=None):
        with UnparserRuleContext(self, 'terminal', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[7], 0, wagGenerator._alt_conds[0]) as alt0:
                current = rule.current
                [self.STRING, self.FLOAT, self.BOOL, self.NUM][alt0()](parent=current)
            current = rule.current
            return current

    def nonTerminal(self, parent=None):
        with UnparserRuleContext(self, 'nonTerminal', parent) as rule:
            current = rule.current
            self.IDENTIFIER(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[4], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.EBNFTYPE(parent=current)
            current = rule.current
            return current

    def nTArgs(self, parent=None):
        with UnparserRuleContext(self, 'nTArgs', parent) as rule:
            current = rule.current
            self._reserve(2, self.LEFT_ANGLE_BRACKET, parent=current)
            self._reserve(1, self.attrIdentifierList, parent=current)
            self.RIGHT_ANGLE_BRACKET(parent=current)
            return current

    def attrIdentifier(self, parent=None):
        with UnparserRuleContext(self, 'attrIdentifier', parent) as rule:
            current = rule.current
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[4], 1) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.ATTRSPEC(parent=current)
            current = rule.current
            self.IDENTIFIER(parent=current)
            return current

    def attrIdentifierList(self, parent=None):
        with UnparserRuleContext(self, 'attrIdentifierList', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[8], 0, wagGenerator._alt_conds[1]) as alt0:
                current = rule.current
                choice0 = alt0()
                if choice0 == 0:
                    self._reserve(2, self.attrIdentifier, parent=current)
                    self._reserve(1, self.DELIMITER, parent=current)
                    self.attrIdentifierList(parent=current)
                elif choice0 == 1:
                    self.attrIdentifier(parent=current)
                elif choice0 == 2:
                    self.STRING(parent=current)
            current = rule.current
            return current

    def assignment(self, parent=None):
        with UnparserRuleContext(self, 'assignment', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[9], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                [self.nTAssigment, self.attributeAssignment][alt0()](parent=current)
            current = rule.current
            return current

    def nTAssigment(self, parent=None):
        with UnparserRuleContext(self, 'nTAssigment', parent) as rule:
            current = rule.current
            self._reserve(3, self.nonTerminal, parent=current)
            self.nTArgs(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[4], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.EBNFTYPE(parent=current)
            current = rule.current
            return current

    def attributeAssignment(self, parent=None):
        with UnparserRuleContext(self, 'attributeAssignment', parent) as rule:
            current = rule.current
            self._reserve(1, self.ATTR_ASSIGN_L, parent=current)
            with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[2], 1) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self._reserve(2, self.attrIdentifier, parent=current)
                        self._reserve(1, self.EQ, parent=current)
                        self._reserve(1, self.expression, parent=current)
                        self.STATEMENT_END(parent=current)
            current = rule.current
            self.ATTR_ASSIGN_R(parent=current)
            return current

    def expression(self, parent=None):
        with UnparserRuleContext(self, 'expression', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[10], 0, wagGenerator._alt_conds[1]) as alt0:
                current = rule.current
                [self.SUBPROC, self.if, self.disjunct][alt0()](parent=current)
            current = rule.current
            return current

    def if(self, parent=None):
        with UnparserRuleContext(self, 'if', parent) as rule:
            current = rule.current
            self._reserve(1, self.IF, parent=current)
            self._reserve(1, self.disjunct, parent=current)
            self.THEN(parent=current)
            self.disjunct(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[1], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.ELSE(parent=current)
                        self.expression(parent=current)
            current = rule.current
            return current

    def disjunct(self, parent=None):
        with UnparserRuleContext(self, 'disjunct', parent) as rule:
            current = rule.current
            self.conjunct(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[8], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.AND(parent=current)
                        self.disjunct(parent=current)
            current = rule.current
            return current

    def conjunct(self, parent=None):
        with UnparserRuleContext(self, 'conjunct', parent) as rule:
            current = rule.current
            self.inverse(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[9], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.OR(parent=current)
                        self.conjunct(parent=current)
            current = rule.current
            return current

    def inverse(self, parent=None):
        with UnparserRuleContext(self, 'inverse', parent) as rule:
            current = rule.current
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[4], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.INVERSE_SIGN(parent=current)
            current = rule.current
            self.comparison(parent=current)
            return current

    def comparison(self, parent=None):
        with UnparserRuleContext(self, 'comparison', parent) as rule:
            current = rule.current
            self.sum(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[10], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.compop(parent=current)
                        self.sum(parent=current)
            current = rule.current
            return current

    def sum(self, parent=None):
        with UnparserRuleContext(self, 'sum', parent) as rule:
            current = rule.current
            self.term(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[10], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.sumP(parent=current)
            current = rule.current
            return current

    def sumP(self, parent=None):
        with UnparserRuleContext(self, 'sumP', parent) as rule:
            current = rule.current
            self.SUMOP(parent=current)
            self.term(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[10], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.sumP(parent=current)
            current = rule.current
            return current

    def term(self, parent=None):
        with UnparserRuleContext(self, 'term', parent) as rule:
            current = rule.current
            self.factor(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[7], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.termP(parent=current)
            current = rule.current
            return current

    def termP(self, parent=None):
        with UnparserRuleContext(self, 'termP', parent) as rule:
            current = rule.current
            self.TERMOP(parent=current)
            self.factor(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[7], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.termP(parent=current)
            current = rule.current
            return current

    def factor(self, parent=None):
        with UnparserRuleContext(self, 'factor', parent) as rule:
            current = rule.current
            self.atom(parent=current)
            with QuantifierContext(rule, 0, 0, 1, wagGenerator._quant_sizes[1], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        self.FACTORIAL(parent=current)
                        self.factor(parent=current)
            current = rule.current
            return current

    def atom(self, parent=None):
        with UnparserRuleContext(self, 'atom', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[11], 0, wagGenerator._alt_conds[3]) as alt0:
                current = rule.current
                choice0 = alt0()
                if choice0 == 0:
                    self.attrIdentifier(parent=current)
                elif choice0 == 1:
                    self.dictonary(parent=current)
                elif choice0 == 2:
                    self.BOOL(parent=current)
                elif choice0 == 3:
                    with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[4], 0) as quant0:
                        while quant0():
                            with QuantifiedContext(rule):
                                current = rule.current
                                self.NUM(parent=current)
                    current = rule.current
                elif choice0 == 4:
                    self.FLOAT(parent=current)
                elif choice0 == 5:
                    self.STRING(parent=current)
                elif choice0 == 6:
                    self._reserve(1, self.LPAREN, parent=current)
                    self._reserve(1, self.expression, parent=current)
                    self.RPAREN(parent=current)
            current = rule.current
            return current

    def dictonary(self, parent=None):
        with UnparserRuleContext(self, 'dictonary', parent) as rule:
            current = rule.current
            self._reserve(1, self.BRACKET_L, parent=current)
            self._reserve(1, self.expression, parent=current)
            self.BRACKET_R(parent=current)
            return current

    def compop(self, parent=None):
        with UnparserRuleContext(self, 'compop', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[12], 0, wagGenerator._alt_conds[3]) as alt0:
                current = rule.current
                [self.LEFT_ANGLE_BRACKET, self.LEQ, self.RIGHT_ANGLE_BRACKET, self.GEQ, self.EQ2, self.NEQ, self.IN][alt0()](parent=current)
            current = rule.current
            return current

    def INCLUDEDECL(self, parent=None):
        with UnlexerRuleContext(self, 'INCLUDEDECL', parent) as rule:
            current = rule.current
            current.src += '::'
            return current

    def PROPESITION_SIGN(self, parent=None):
        with UnlexerRuleContext(self, 'PROPESITION_SIGN', parent) as rule:
            current = rule.current
            current.src += '->'
            return current

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as rule:
            current = rule.current
            current.src += self._model.charset(current, 0, wagGenerator._charsets[1])
            with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[0], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        current.src += self._model.charset(current, 1, wagGenerator._charsets[2])
            current = rule.current
            return current

    def TERMOP(self, parent=None):
        with UnlexerRuleContext(self, 'TERMOP', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[0], 0, wagGenerator._alt_conds[0]) as alt0:
                current = rule.current
                current.src += ['*', '//', '/', '%'][alt0()]
            current = rule.current
            return current

    def ATTRSPEC(self, parent=None):
        with UnlexerRuleContext(self, 'ATTRSPEC', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[1], 0, wagGenerator._alt_conds[1]) as alt0:
                current = rule.current
                current.src += ['$', '*', '&'][alt0()]
            current = rule.current
            return current

    def SUMOP(self, parent=None):
        with UnlexerRuleContext(self, 'SUMOP', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[2], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                current.src += ['+', '-'][alt0()]
            current = rule.current
            return current

    def EBNFTYPE(self, parent=None):
        with UnlexerRuleContext(self, 'EBNFTYPE', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[1], 0, wagGenerator._alt_conds[1]) as alt0:
                current = rule.current
                current.src += ['@', '~', '?'][alt0()]
            current = rule.current
            return current

    def BOOL(self, parent=None):
        with UnlexerRuleContext(self, 'BOOL', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[2], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                current.src += ['true', 'false'][alt0()]
            current = rule.current
            return current

    def NUM(self, parent=None):
        with UnlexerRuleContext(self, 'NUM', parent) as rule:
            current = rule.current
            current.src += self._model.charset(current, 0, wagGenerator._charsets[3])
            return current

    def FLOAT(self, parent=None):
        with UnlexerRuleContext(self, 'FLOAT', parent) as rule:
            current = rule.current
            with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[0], 0) as quant0:
                while quant0():
                    with QuantifiedContext(rule):
                        current = rule.current
                        current.src += self._model.charset(current, 0, wagGenerator._charsets[3])
            current = rule.current
            current.src += '.'
            with QuantifierContext(rule, 1, 0, inf, wagGenerator._quant_sizes[0], 0) as quant1:
                while quant1():
                    with QuantifiedContext(rule):
                        current = rule.current
                        current.src += self._model.charset(current, 1, wagGenerator._charsets[3])
            current = rule.current
            return current

    def STRING(self, parent=None):
        with UnlexerRuleContext(self, 'STRING', parent) as rule:
            current = rule.current
            with AlternationContext(rule, 0, wagGenerator._alt_sizes[2], 0, wagGenerator._alt_conds[2]) as alt0:
                current = rule.current
                choice0 = alt0()
                if choice0 == 0:
                    current.src += '"'
                    with QuantifierContext(rule, 0, 0, inf, wagGenerator._quant_sizes[0], 0) as quant0:
                        while quant0():
                            with QuantifiedContext(rule):
                                current = rule.current
                                current.src += self._model.charset(current, 0, wagGenerator._charsets[4])
                    current = rule.current
                    current.src += '"'
                elif choice0 == 1:
                    current.src += '\''
                    with QuantifierContext(rule, 1, 0, inf, wagGenerator._quant_sizes[0], 0) as quant1:
                        while quant1():
                            with QuantifiedContext(rule):
                                current = rule.current
                                current.src += self._model.charset(current, 1, wagGenerator._charsets[4])
                    current = rule.current
                    current.src += '\''
            current = rule.current
            return current

    def EBNF_OPTION(self, parent=None):
        with UnlexerRuleContext(self, 'EBNF_OPTION', parent) as rule:
            current = rule.current
            current.src += '|'
            return current

    def SUBPROC(self, parent=None):
        with UnlexerRuleContext(self, 'SUBPROC', parent) as rule:
            current = rule.current
            current.src += '$( /[^)]*/ )'
            return current

    def DECLARATION(self, parent=None):
        with UnlexerRuleContext(self, 'DECLARATION', parent) as rule:
            current = rule.current
            current.src += ':'
            return current

    def STATEMENT_END(self, parent=None):
        with UnlexerRuleContext(self, 'STATEMENT_END', parent) as rule:
            current = rule.current
            current.src += ';'
            return current

    def EQ(self, parent=None):
        with UnlexerRuleContext(self, 'EQ', parent) as rule:
            current = rule.current
            current.src += '='
            return current

    def META_END(self, parent=None):
        with UnlexerRuleContext(self, 'META_END', parent) as rule:
            current = rule.current
            current.src += '****'
            return current

    def INVERSE_SIGN(self, parent=None):
        with UnlexerRuleContext(self, 'INVERSE_SIGN', parent) as rule:
            current = rule.current
            current.src += '!'
            return current

    def BRACKET_L(self, parent=None):
        with UnlexerRuleContext(self, 'BRACKET_L', parent) as rule:
            current = rule.current
            current.src += '['
            return current

    def BRACKET_R(self, parent=None):
        with UnlexerRuleContext(self, 'BRACKET_R', parent) as rule:
            current = rule.current
            current.src += ']'
            return current

    def ATTR_ASSIGN_L(self, parent=None):
        with UnlexerRuleContext(self, 'ATTR_ASSIGN_L', parent) as rule:
            current = rule.current
            current.src += '{'
            return current

    def ATTR_ASSIGN_R(self, parent=None):
        with UnlexerRuleContext(self, 'ATTR_ASSIGN_R', parent) as rule:
            current = rule.current
            current.src += '}'
            return current

    def LPAREN(self, parent=None):
        with UnlexerRuleContext(self, 'LPAREN', parent) as rule:
            current = rule.current
            current.src += '('
            return current

    def RPAREN(self, parent=None):
        with UnlexerRuleContext(self, 'RPAREN', parent) as rule:
            current = rule.current
            current.src += ')'
            return current

    def LEFT_ANGLE_BRACKET(self, parent=None):
        with UnlexerRuleContext(self, 'LEFT_ANGLE_BRACKET', parent) as rule:
            current = rule.current
            current.src += '<'
            return current

    def RIGHT_ANGLE_BRACKET(self, parent=None):
        with UnlexerRuleContext(self, 'RIGHT_ANGLE_BRACKET', parent) as rule:
            current = rule.current
            current.src += '>'
            return current

    def DELIMITER(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITER', parent) as rule:
            current = rule.current
            current.src += ','
            return current

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as rule:
            current = rule.current
            current.src += 'if'
            return current

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as rule:
            current = rule.current
            current.src += 'else'
            return current

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as rule:
            current = rule.current
            current.src += 'then'
            return current

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as rule:
            current = rule.current
            current.src += '&&'
            return current

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as rule:
            current = rule.current
            current.src += '||'
            return current

    def FACTORIAL(self, parent=None):
        with UnlexerRuleContext(self, 'FACTORIAL', parent) as rule:
            current = rule.current
            current.src += '**'
            return current

    def LEQ(self, parent=None):
        with UnlexerRuleContext(self, 'LEQ', parent) as rule:
            current = rule.current
            current.src += '<='
            return current

    def GEQ(self, parent=None):
        with UnlexerRuleContext(self, 'GEQ', parent) as rule:
            current = rule.current
            current.src += '>='
            return current

    def EQ2(self, parent=None):
        with UnlexerRuleContext(self, 'EQ2', parent) as rule:
            current = rule.current
            current.src += '=='
            return current

    def NEQ(self, parent=None):
        with UnlexerRuleContext(self, 'NEQ', parent) as rule:
            current = rule.current
            current.src += '!='
            return current

    def IN(self, parent=None):
        with UnlexerRuleContext(self, 'IN', parent) as rule:
            current = rule.current
            current.src += 'in'
            return current


    _default_rule = wag

    _immutable_rules = ('AND', 'ATTR_ASSIGN_L', 'ATTR_ASSIGN_R', 'BRACKET_L', 'BRACKET_R', 'DECLARATION', 'DELIMITER', 'EBNF_OPTION', 'ELSE', 'EQ', 'EQ2', 'FACTORIAL', 'GEQ', 'IF', 'IN', 'INCLUDEDECL', 'INVERSE_SIGN', 'LEFT_ANGLE_BRACKET', 'LEQ', 'LPAREN', 'META_END', 'NEQ', 'OR', 'PROPESITION_SIGN', 'RIGHT_ANGLE_BRACKET', 'RPAREN', 'STATEMENT_END', 'SUBPROC', 'THEN')

    _rule_sizes = {
        'wag': RuleSize(0, 0),
        'metadata': RuleSize(1, 1),
        'meta': RuleSize(2, 2),
        'include': RuleSize(1, 2),
        'config': RuleSize(1, 4),
        'rule': RuleSize(1, 3),
        'rhs': RuleSize(0, 0),
        'weight': RuleSize(2, 2),
        'chunk': RuleSize(2, 1),
        'chunkP': RuleSize(1, 1),
        'symbol': RuleSize(2, 1),
        'terminal': RuleSize(1, 1),
        'nonTerminal': RuleSize(1, 1),
        'nTArgs': RuleSize(2, 3),
        'attrIdentifier': RuleSize(1, 1),
        'attrIdentifierList': RuleSize(1, 1),
        'assignment': RuleSize(2, 2),
        'nTAssigment': RuleSize(3, 4),
        'attributeAssignment': RuleSize(1, 2),
        'expression': RuleSize(1, 0),
        'if': RuleSize(8, 2),
        'disjunct': RuleSize(7, 0),
        'conjunct': RuleSize(6, 0),
        'inverse': RuleSize(5, 0),
        'comparison': RuleSize(4, 0),
        'sum': RuleSize(3, 0),
        'sumP': RuleSize(3, 1),
        'term': RuleSize(2, 0),
        'termP': RuleSize(2, 1),
        'factor': RuleSize(1, 0),
        'atom': RuleSize(0, 0),
        'dictonary': RuleSize(2, 2),
        'compop': RuleSize(1, 1),
        'INCLUDEDECL': RuleSize(0, 0),
        'PROPESITION_SIGN': RuleSize(0, 0),
        'IDENTIFIER': RuleSize(0, 0),
        'TERMOP': RuleSize(0, 0),
        'ATTRSPEC': RuleSize(0, 0),
        'SUMOP': RuleSize(0, 0),
        'EBNFTYPE': RuleSize(0, 0),
        'BOOL': RuleSize(0, 0),
        'NUM': RuleSize(0, 0),
        'FLOAT': RuleSize(0, 0),
        'STRING': RuleSize(0, 0),
        'EBNF_OPTION': RuleSize(0, 0),
        'SUBPROC': RuleSize(0, 0),
        'DECLARATION': RuleSize(0, 0),
        'STATEMENT_END': RuleSize(0, 0),
        'EQ': RuleSize(0, 0),
        'META_END': RuleSize(0, 0),
        'INVERSE_SIGN': RuleSize(0, 0),
        'BRACKET_L': RuleSize(0, 0),
        'BRACKET_R': RuleSize(0, 0),
        'ATTR_ASSIGN_L': RuleSize(0, 0),
        'ATTR_ASSIGN_R': RuleSize(0, 0),
        'LPAREN': RuleSize(0, 0),
        'RPAREN': RuleSize(0, 0),
        'LEFT_ANGLE_BRACKET': RuleSize(0, 0),
        'RIGHT_ANGLE_BRACKET': RuleSize(0, 0),
        'DELIMITER': RuleSize(0, 0),
        'IF': RuleSize(0, 0),
        'ELSE': RuleSize(0, 0),
        'THEN': RuleSize(0, 0),
        'AND': RuleSize(0, 0),
        'OR': RuleSize(0, 0),
        'FACTORIAL': RuleSize(0, 0),
        'LEQ': RuleSize(0, 0),
        'GEQ': RuleSize(0, 0),
        'EQ2': RuleSize(0, 0),
        'NEQ': RuleSize(0, 0),
        'IN': RuleSize(0, 0),
    }

    _alt_sizes = (
        (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)),  # 0
        (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)),  # 1
        (RuleSize(0, 0), RuleSize(0, 0)),  # 2
        (RuleSize(2, 2), RuleSize(2, 4)),  # 3
        (RuleSize(1, 1), RuleSize(0, 0)),  # 4
        (RuleSize(3, 1), RuleSize(1, 2)),  # 5
        (RuleSize(2, 1), RuleSize(2, 1), RuleSize(3, 2)),  # 6
        (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)),  # 7
        (RuleSize(2, 3), RuleSize(2, 1), RuleSize(1, 1)),  # 8
        (RuleSize(4, 4), RuleSize(2, 2)),  # 9
        (RuleSize(1, 1), RuleSize(9, 2), RuleSize(8, 0)),  # 10
        (RuleSize(2, 1), RuleSize(3, 2), RuleSize(1, 1), RuleSize(0, 0), RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 2)),  # 11
        (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)),  # 12
    )

    _alt_conds = (
        (1, 1, 1, 1),  # 0
        (1, 1, 1),  # 1
        (1, 1),  # 2
        (1, 1, 1, 1, 1, 1, 1),  # 3
    )

    _quant_sizes = (
        RuleSize(0, 0),  # 0
        RuleSize(2, 1),  # 1
        RuleSize(2, 3),  # 2
        RuleSize(3, 2),  # 3
        RuleSize(1, 1),  # 4
        RuleSize(2, 2),  # 5
        RuleSize(3, 3),  # 6
        RuleSize(3, 1),  # 7
        RuleSize(8, 1),  # 8
        RuleSize(7, 1),  # 9
        RuleSize(4, 1),  # 10
    )

    _charsets = (
        Generator._charset(((0x20, 0x7f), )),  # 0
        Generator._charset(((0x41, 0x5b), (0x61, 0x7b), )),  # 1
        Generator._charset(((0x30, 0x3a), (0x41, 0x5b), (0x5f, 0x60), (0x61, 0x7b), )),  # 2
        Generator._charset(((0x30, 0x3a), )),  # 3
        Generator._charset(((0x20, 0x22), (0x23, 0x7f), )),  # 4
    )
